#!/bin/bash
#
# create_makefile.sh: semantic dependency graph for LilyPond projects
#
# Usage:
#   ./create_makefile.sh
#   make
#
# Originally written by William Chargin <wchargin@gmail.com>. Released
# under the MIT License.
set -eu

# Identify non-transitive dependencies of LilyPond file $1 by analyzing
# the document structure. Output is a NUL-delimited stream of filenames.
deps() {
    # shellcheck disable=SC2094
    <"$1" tr '\n' '\0' |
        sed -zne 's/.*\\include "\([^"]\+\)".*/\1/p' | \
        zawk -v base="$(dirname "$1")" '{ print base "/" $0 }' | \
        sed -z 's:/[^/]\+/../:/:g' | \
        lydep_names | \
        sort -zu
}

# Print the lydep file associated with each input file. For instance,
# `foo.ly` becomes `.foo.ly.lydep`. Input and output are NUL-delimited
# streams of filenames.
lydep_names() {
    zawk -v FS="/" -v OFS="/" '{ $NF = "." $NF ".lydep"; print }'
}

# Like awk(1), but with NUL-delimited records (both input and output).
zawk() {
    awk -v RS='\0' -v ORS='\0' "$@"
}

# Print the lydep file associated with the input file $1.
lydep_name() {
    printf '%s\0' "$1" | lydep_names | tr -d '\0'
}

# Emit a Make rule for the lydep file associated with the LilyPond file
# specified in $1.
ly_rule() {
    filename="$1"
    printf '.INTERMEDIATE: %s\n' "$(lydep_name "${filename}")"
    printf '%s: \\\n\t\t%s' "$(lydep_name "${filename}")" "${filename}"
    deps "${filename}" | while read -r -d $'\0' dep; do
        printf ' \\\n\t\t%s' "${dep}"
    done
    printf '\n'
}

# Emit Make rules for all lydep files.
ly_depgraph() {
    find . \( -name '*.ly' -o -name '*.ily' \) -print0 | sort -z | \
        while read -r -d $'\0' filename; do
            ly_rule "${filename}"
        done
}

# Emit a Make rule indicating that output $1 can be created by running
# LilyPond on $2, with appropriate transitive dependencies.
ly_entry_point() {
    printf '%s: %s\n' "$1" "$(lydep_name "$2")"
    # shellcheck disable=SC2016
    printf '\t$(LY) %s\n' "$2"
}

# Emit the main Makefile.
makefile() {
    main=MozartWA-KV488-conductor
    midi=MozartWA-KV488-midi
    midis=( kv488-{1-allegro,2-andante,3-presto} )
    parts=( )
    for filename in *-part-*.ly; do
        parts+=( "${filename%.ly}" )
    done

    printf '# AUTOGENERATED MAKEFILE --- DO NOT EDIT\n'
    printf '# Run "%s" to regenerate\n' "$(basename "$0")"
    printf '\n'

    # shellcheck disable=SC2016
    printf 'LY ?= lilypond -dno-point-and-click $(LYFLAGS)\n'
    printf 'ifdef PAPERSIZE\n'
    # shellcheck disable=SC2016
    printf '\tLYFLAGS += -dpaper-size=%s\n' '\"$(PAPERSIZE)\"'
    printf 'endif\n'
    printf '\n'

    printf '# Metatargets, for convenience\n'
    printf '.PHONY: all main parts midi quicktest test quickcheck check clean\n'
    printf 'all: main parts midi\n'
    printf 'main: %s\n' "${main}.pdf"
    printf 'parts:'
    for part in "${parts[@]}"; do
        printf ' \\\n\t\t%s.pdf' "${part}"
    done
    printf '\n'
    printf 'midi:'
    printf ' \\\n\t\t%s.midi' "${midis[@]}"
    printf '\n'
    printf 'quicktest quickcheck:\n'
    printf '\t%s\n' ./assert_barchecks.sh
    printf 'test check: quicktest\n'
    # shellcheck disable=SC2016
    printf \
        '\t! $(MAKE) all -B PAPERSIZE=%s 2>&1 | grep -F -e err -e warn >&2\n' \
        a4 letter
    printf 'clean:\n'
    # shellcheck disable=SC2016
    printf '\t$(RM) "%s.midi"\n' "${midis[@]}"
    # shellcheck disable=SC2016
    printf '\t$(RM) "%s"\n' "${main}.pdf"
    # shellcheck disable=SC2016
    printf '\t$(RM) "%s.pdf"\n' "${parts[@]}"
    printf '\n'

    printf '# LilyPond entry points\n'
    ly_entry_point "${main}.pdf" "${main}.ly"
    for part in "${parts[@]}"; do
        ly_entry_point "${part}.pdf" "${part}.ly"
    done
    printf '.INTERMEDIATE: __run_midi\n'
    for m in "${midis[@]}"; do
        printf '%s.midi: __run_midi\n' "${m}"
    done
    ly_entry_point "__run_midi" "${midi}.ly"

    printf '\n'
    printf '# LilyPond dependency graph\n'
    ly_depgraph
}

cd "$(dirname "$(readlink -f "$0")")"
makefile >Makefile
